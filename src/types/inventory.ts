/**
 * RHY Supplier Portal - Inventory Management Types
 * Enterprise-grade inventory system for real-time multi-warehouse operations
 * Integrates with Batch 1 authentication and warehouse foundation
 */

/* eslint-disable no-unused-vars */



import { z } from 'zod'

// ================================
// CORE INVENTORY TYPES
// ================================

export interface InventoryItem {
  id: string
  warehouseId: string
  productId: string
  sku: string
  productName: string
  category: 'FLEXVOLT_6AH' | 'FLEXVOLT_9AH' | 'FLEXVOLT_15AH' | 'ACCESSORIES' | 'CHARGERS'
  currentQuantity: number
  reservedQuantity: number
  availableQuantity: number
  reorderPoint: number
  maxStockLevel: number
  minStockLevel: number
  status: 'IN_STOCK' | 'LOW_STOCK' | 'OUT_OF_STOCK' | 'OVERSTOCK' | 'DISCONTINUED'
  location: string
  binLocation?: string
  costPerUnit: number
  retailPrice: number
  lastMovement: Date
  lastCountedAt?: Date
  syncStatus: 'SYNCED' | 'SYNCING' | 'ERROR' | 'PENDING'
  warehouse: {
    id: string
    name: string
    region: 'US' | 'JP' | 'EU' | 'AU'
    code: string
  }
  product: {
    id: string
    name: string
    sku: string
    specifications: Record<string, any>
    dimensions: {
      weight: number
      length: number
      width: number
      height: number
    }
  }
  movements: InventoryMovement[]
  alerts: InventoryAlert[]
  metadata: {
    supplier?: string
    batchNumber?: string
    expirationDate?: Date
    qualityGrade?: 'A' | 'B' | 'C'
    notes?: string
  }
  createdAt: Date
  updatedAt: Date
  updatedBy: string
}

export interface InventoryMovement {
  id: string
  inventoryItemId: string
  type: 'INBOUND' | 'OUTBOUND' | 'TRANSFER' | 'ADJUSTMENT' | 'RETURN' | 'DAMAGE' | 'COUNT'
  quantity: number
  fromLocation?: string
  toLocation?: string
  fromWarehouse?: string
  toWarehouse?: string
  reason: string
  reference?: string
  orderId?: string
  supplierId?: string
  cost?: number
  userId: string
  timestamp: Date
  metadata: {
    source: 'MANUAL' | 'AUTOMATED' | 'TRANSFER' | 'API'
    batchId?: string
    documentNumber?: string
    notes?: string
  }
}

export interface InventoryAlert {
  id: string
  inventoryItemId: string
  warehouseId: string
  type: 'LOW_STOCK' | 'OUT_OF_STOCK' | 'OVERSTOCK' | 'EXPIRING' | 'SYNC_ERROR' | 'DAMAGE'
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  title: string
  message: string
  threshold?: number
  currentValue?: number
  recommendedAction: string
  suggestedOrderQuantity?: number
  estimatedStockoutDate?: Date
  acknowledged: boolean
  acknowledgedBy?: string
  acknowledgedAt?: Date
  resolved: boolean
  resolvedBy?: string
  resolvedAt?: Date
  createdAt: Date
  metadata: {
    autoGenerated: boolean
    triggerConditions: Record<string, any>
    priority: number
  }
}

export interface InventoryDashboard {
  warehouseId: string
  warehouseName: string
  region: 'US' | 'JP' | 'EU' | 'AU'
  summary: {
    totalItems: number
    totalValue: number
    inStockItems: number
    lowStockItems: number
    outOfStockItems: number
    overstockItems: number
    pendingSyncItems: number
    alertsCount: number
    criticalAlertsCount: number
  }
  categoryBreakdown: Array<{
    category: string
    totalItems: number
    totalQuantity: number
    totalValue: number
    averageStockLevel: number
    alertsCount: number
  }>
  recentMovements: InventoryMovement[]
  activeAlerts: InventoryAlert[]
  performanceMetrics: {
    stockAccuracy: number
    turnoverRate: number
    fillRate: number
    averageDaysToStockout: number
    syncSuccessRate: number
  }
  predictions: {
    nextStockouts: Array<{
      productId: string
      productName: string
      estimatedDate: Date
      confidence: number
    }>
    reorderRecommendations: Array<{
      productId: string
      productName: string
      currentStock: number
      suggestedQuantity: number
      urgency: 'LOW' | 'MEDIUM' | 'HIGH'
      reasoning: string
    }>
  }
  lastUpdated: Date
}

export interface MultiWarehouseInventory {
  productId: string
  productName: string
  sku: string
  category: string
  globalStock: {
    totalQuantity: number
    totalValue: number
    averagePrice: number
  }
  warehouseBreakdown: Array<{
    warehouseId: string
    warehouseName: string
    region: 'US' | 'JP' | 'EU' | 'AU'
    quantity: number
    available: number
    reserved: number
    status: string
    lastUpdated: Date
  }>
  transferOpportunities: Array<{
    fromWarehouse: string
    toWarehouse: string
    suggestedQuantity: number
    estimatedCost: number
    estimatedTime: string
    priority: 'LOW' | 'MEDIUM' | 'HIGH'
  }>
  globalAlerts: InventoryAlert[]
  syncStatus: 'SYNCED' | 'SYNCING' | 'ERROR'
  lastGlobalSync: Date
}

export interface InventoryTransfer {
  id: string
  fromWarehouseId: string
  toWarehouseId: string
  fromWarehouse: {
    id: string
    name: string
    region: string
  }
  toWarehouse: {
    id: string
    name: string
    region: string
  }
  items: Array<{
    inventoryItemId: string
    productId: string
    productName: string
    sku: string
    quantity: number
    costPerUnit: number
    totalCost: number
  }>
  status: 'PENDING' | 'APPROVED' | 'IN_TRANSIT' | 'DELIVERED' | 'CANCELLED' | 'ERROR'
  requestedBy: string
  approvedBy?: string
  shippedAt?: Date
  deliveredAt?: Date
  estimatedArrival?: Date
  trackingNumber?: string
  totalCost: number
  totalItems: number
  totalQuantity: number
  reason: string
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'URGENT'
  metadata: {
    autoGenerated: boolean
    optimizationScore?: number
    route?: {
      distance: number
      estimatedDuration: string
      carrier: string
    }
    documents: Array<{
      type: string
      url: string
      uploadedAt: Date
    }>
  }
  createdAt: Date
  updatedAt: Date
}

export interface InventoryForecast {
  productId: string
  warehouseId: string
  period: 'WEEKLY' | 'MONTHLY' | 'QUARTERLY'
  demandForecast: Array<{
    date: Date
    predictedDemand: number
    confidence: number
    factors: Array<{
      name: string
      impact: number
      type: 'SEASONAL' | 'TREND' | 'EVENT' | 'HISTORICAL'
    }>
  }>
  stockProjection: Array<{
    date: Date
    projectedStock: number
    reorderPoints: Date[]
    stockoutRisk: number
  }>
  recommendations: Array<{
    action: 'REORDER' | 'TRANSFER' | 'LIQUIDATE' | 'MONITOR'
    quantity?: number
    targetDate: Date
    reasoning: string
    expectedImpact: string
  }>
  accuracy: {
    lastPeriodAccuracy: number
    historicalAccuracy: number
    confidenceLevel: number
  }
  generatedAt: Date
  validUntil: Date
}

// ================================
// REQUEST/RESPONSE INTERFACES
// ================================

export interface InventoryQuery {
  warehouseId?: string
  region?: 'US' | 'JP' | 'EU' | 'AU'
  category?: string
  status?: string[]
  search?: string
  minQuantity?: number
  maxQuantity?: number
  alertsOnly?: boolean
  syncStatus?: string[]
  page?: number
  limit?: number
  sortBy?: 'name' | 'quantity' | 'lastMovement' | 'status' | 'value'
  sortOrder?: 'asc' | 'desc'
  includeAlerts?: boolean
  includeMovements?: boolean
  includePredictions?: boolean
}

export interface InventoryUpdateRequest {
  inventoryItemId: string
  quantity?: number
  location?: string
  binLocation?: string
  reorderPoint?: number
  maxStockLevel?: number
  minStockLevel?: number
  status?: string
  notes?: string
  reason: string
  userId: string
}

export interface BulkInventoryUpdateRequest {
  updates: InventoryUpdateRequest[]
  reason: string
  batchId?: string
  validateOnly?: boolean
  userId: string
}

export interface InventoryCountRequest {
  warehouseId: string
  items: Array<{
    inventoryItemId: string
    countedQuantity: number
    location?: string
    condition?: 'GOOD' | 'DAMAGED' | 'EXPIRED'
    notes?: string
  }>
  countType: 'FULL' | 'CYCLE' | 'SPOT' | 'AUDIT'
  countedBy: string
  metadata?: {
    equipment?: string
    method?: 'MANUAL' | 'SCANNER' | 'RFID'
    accuracy?: number
  }
}

export interface TransferRequest {
  fromWarehouseId: string
  toWarehouseId: string
  items: Array<{
    inventoryItemId: string
    quantity: number
  }>
  reason: string
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'URGENT'
  requestedDeliveryDate?: Date
  notes?: string
  requestedBy: string
}

export interface ReorderRequest {
  warehouseId: string
  items: Array<{
    productId: string
    quantity: number
    urgency: 'LOW' | 'MEDIUM' | 'HIGH'
    targetDate?: Date
  }>
  supplierId?: string
  reason: string
  requestedBy: string
}

// ================================
// RESPONSE INTERFACES
// ================================

export interface InventoryResponse {
  success: boolean
  data?: InventoryItem[]
  total?: number
  hasMore?: boolean
  pagination?: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
  summary?: {
    totalItems: number
    totalValue: number
    alertsCount: number
  }
  error?: string
  timestamp: Date
}

export interface InventoryDashboardResponse {
  success: boolean
  data?: InventoryDashboard
  error?: string
  timestamp: Date
}

export interface MultiWarehouseResponse {
  success: boolean
  data?: MultiWarehouseInventory[]
  summary?: {
    totalProducts: number
    totalGlobalStock: number
    totalValue: number
    syncStatus: string
    lastGlobalSync: Date
  }
  error?: string
  timestamp: Date
}

export interface TransferResponse {
  success: boolean
  data?: InventoryTransfer
  error?: string
  timestamp: Date
}

export interface BulkUpdateResponse {
  success: boolean
  data?: {
    updated: InventoryItem[]
    failed: Array<{
      inventoryItemId: string
      error: string
      originalRequest: InventoryUpdateRequest
    }>
    summary: {
      totalRequested: number
      successful: number
      failed: number
      warnings: string[]
    }
  }
  error?: string
  timestamp: Date
}

// ================================
// VALIDATION SCHEMAS
// ================================

export const InventoryQuerySchema = z.object({
  warehouseId: z.string().uuid().optional(),
  region: z.enum(['US', 'JP', 'EU', 'AU']).optional(),
  category: z.string().optional(),
  status: z.array(z.string()).optional(),
  search: z.string().max(100).optional(),
  minQuantity: z.number().min(0).optional(),
  maxQuantity: z.number().min(0).optional(),
  alertsOnly: z.boolean().optional(),
  syncStatus: z.array(z.string()).optional(),
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20),
  sortBy: z.enum(['name', 'quantity', 'lastMovement', 'status', 'value']).default('name'),
  sortOrder: z.enum(['asc', 'desc']).default('asc'),
  includeAlerts: z.boolean().default(true),
  includeMovements: z.boolean().default(false),
  includePredictions: z.boolean().default(false)
})

export const InventoryUpdateSchema = z.object({
  inventoryItemId: z.string().uuid(),
  quantity: z.number().min(0).optional(),
  location: z.string().max(50).optional(),
  binLocation: z.string().max(20).optional(),
  reorderPoint: z.number().min(0).optional(),
  maxStockLevel: z.number().min(0).optional(),
  minStockLevel: z.number().min(0).optional(),
  status: z.enum(['IN_STOCK', 'LOW_STOCK', 'OUT_OF_STOCK', 'OVERSTOCK', 'DISCONTINUED']).optional(),
  notes: z.string().max(500).optional(),
  reason: z.string().min(1).max(200),
  userId: z.string().uuid()
}).refine(data => {
  if (data.minStockLevel && data.maxStockLevel) {
    return data.minStockLevel <= data.maxStockLevel
  }
  return true
}, {
  message: "Minimum stock level cannot be greater than maximum stock level"
})

export const BulkInventoryUpdateSchema = z.object({
  updates: z.array(InventoryUpdateSchema).min(1).max(100),
  reason: z.string().min(1).max(200),
  batchId: z.string().optional(),
  validateOnly: z.boolean().default(false),
  userId: z.string().uuid()
})

export const TransferRequestSchema = z.object({
  fromWarehouseId: z.string().uuid(),
  toWarehouseId: z.string().uuid(),
  items: z.array(z.object({
    inventoryItemId: z.string().uuid(),
    quantity: z.number().min(1)
  })).min(1).max(50),
  reason: z.string().min(1).max(500),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'URGENT']).default('MEDIUM'),
  requestedDeliveryDate: z.date().optional(),
  notes: z.string().max(1000).optional(),
  requestedBy: z.string().uuid()
}).refine(data => data.fromWarehouseId !== data.toWarehouseId, {
  message: "Source and destination warehouses must be different"
})

export const InventoryCountSchema = z.object({
  warehouseId: z.string().uuid(),
  items: z.array(z.object({
    inventoryItemId: z.string().uuid(),
    countedQuantity: z.number().min(0),
    location: z.string().max(50).optional(),
    condition: z.enum(['GOOD', 'DAMAGED', 'EXPIRED']).default('GOOD'),
    notes: z.string().max(200).optional()
  })).min(1).max(500),
  countType: z.enum(['FULL', 'CYCLE', 'SPOT', 'AUDIT']),
  countedBy: z.string().uuid(),
  metadata: z.object({
    equipment: z.string().max(100).optional(),
    method: z.enum(['MANUAL', 'SCANNER', 'RFID']).default('MANUAL'),
    accuracy: z.number().min(0).max(100).optional()
  }).optional()
})

export const ReorderRequestSchema = z.object({
  warehouseId: z.string().uuid(),
  items: z.array(z.object({
    productId: z.string().uuid(),
    quantity: z.number().min(1),
    urgency: z.enum(['LOW', 'MEDIUM', 'HIGH']).default('MEDIUM'),
    targetDate: z.date().optional()
  })).min(1).max(100),
  supplierId: z.string().uuid().optional(),
  reason: z.string().min(1).max(500),
  requestedBy: z.string().uuid()
})

// ================================
// REAL-TIME SYNC TYPES
// ================================

export interface SyncEvent {
  id: string
  type: 'INVENTORY_UPDATE' | 'STOCK_ALERT' | 'TRANSFER_UPDATE' | 'SYNC_STATUS'
  warehouseId: string
  inventoryItemId?: string
  data: Record<string, any>
  timestamp: Date
  userId?: string
}

export interface SyncStatus {
  warehouseId: string
  status: 'SYNCING' | 'SYNCED' | 'ERROR' | 'OFFLINE'
  lastSync: Date
  nextSync?: Date
  errors?: string[]
  pendingUpdates: number
  conflicts: Array<{
    inventoryItemId: string
    issue: string
    localValue: any
    remoteValue: any
  }>
}

// ================================
// ANALYTICS & REPORTING TYPES
// ================================

export interface InventoryAnalytics {
  warehouseId?: string
  region?: 'US' | 'JAPAN' | 'EU' | 'AUSTRALIA'
  dateRange: {
    start: Date
    end: Date
  }
  generatedAt: Date
  generatedBy: string
  
  // Core metrics
  turnoverMetrics: TurnoverMetrics | null
  stockLevels: {
    totalItems: number
    totalValue: number
    flexVoltBreakdown: {
      '6Ah': InventoryItem[]
      '9Ah': InventoryItem[]
      '15Ah': InventoryItem[]
    }
    stockStatus: {
      inStock: InventoryItem[]
      lowStock: InventoryItem[]
      outOfStock: InventoryItem[]
      overstock: InventoryItem[]
    }
    regionalDistribution?: any
    valueAnalysis?: any
    lastUpdated: Date
  } | null
  demandForecasting: any | null
  optimizationSuggestions: StockOptimization[] | null
  performanceMetrics: InventoryPerformanceReport | null
  
  // Advanced insights
  trends: InventoryTrend[] | null
  alerts: InventoryAlert[] | null
  recommendations: SmartRecommendation[] | null
  
  // Multi-warehouse data if applicable
  multiWarehouseComparison: MultiWarehouseInventoryData | null
  
  // Performance metadata
  metadata: {
    processingTime: number
    dataPoints: number
    lastUpdated: Date
    cacheStatus: string
    granularity: string
  }
}

export interface TurnoverMetrics {
  period: {
    start: Date
    end: Date
  }
  warehouseId?: string
  overallTurnover: {
    turnoverRate: number
    averageDaysInStock: number
    totalStock: number
    totalMovements: number
  }
  productTurnovers: Array<{
    productId: string
    productName: string
    turnoverRate: number
    benchmark: number
    revenue: number
    daysInStock: number
    trend: string
  }>
  benchmarks: {
    industryAverage: number
    companyAverage: number
    target: number
  }
  trends: {
    trend: string
    direction: 'up' | 'down' | 'stable'
    seasonalFactor: number
    projectedNextPeriod: number
  }
  recommendations: Array<{
    type: string
    products: string[]
    suggestion: string
    impact: string
    priority: 'HIGH' | 'MEDIUM' | 'LOW'
  }>
  calculatedAt: Date
}

export interface StockOptimization {
  type: string
  priority: 'HIGH' | 'MEDIUM' | 'LOW'
  description: string
  impact: any
  recommendations: string[]
  affectedProducts: string[]
}

export interface InventoryTrend {
  metric: string
  direction: 'up' | 'down' | 'stable'
  percentage: number
  period: string
}

export interface InventoryAlert {
  type: string
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
  message: string
  actionRequired: string
}

export interface SmartRecommendation {
  title: string
  description: string
  priority: 'HIGH' | 'MEDIUM' | 'LOW'
  impact: {
    financial: number
    timeframe: string
  }
}

export interface MultiWarehouseInventoryData {
  regions: Array<{
    region: string
    totalValue: number
    inventoryCount: number
    performance: number
  }>
}

export interface InventoryPerformanceReport {
  warehouseId?: string
  reportPeriod: {
    start: Date
    end: Date
  }
  accuracy: {
    accuracy: number
    variance: number
  }
  efficiency: {
    efficiency: number
    throughput: number
  }
  compliance: {
    complianceScore: number
    issues: number
  }
  costs: {
    totalCosts: number
    costPerUnit: number
  }
  overallScore: number
  trends: any
  comparisons: any[]
  generatedAt: Date
}

// ================================
// UTILITY TYPES
// ================================

export type InventoryEventType = 
  | 'STOCK_RECEIVED'
  | 'STOCK_SHIPPED'
  | 'STOCK_TRANSFERRED'
  | 'STOCK_ADJUSTED'
  | 'ALERT_GENERATED'
  | 'ALERT_RESOLVED'
  | 'SYNC_COMPLETED'
  | 'SYNC_FAILED'

export type AlertPriority = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'

export type SyncStrategy = 'REAL_TIME' | 'BATCH' | 'SCHEDULED' | 'MANUAL'

export interface InventoryConfig {
  warehouseId: string
  syncStrategy: SyncStrategy
  syncInterval?: number // in minutes
  alertThresholds: {
    lowStockPercent: number
    overstockPercent: number
    stockoutDays: number
  }
  autoReorder: {
    enabled: boolean
    rules: Array<{
      category: string
      reorderMultiplier: number
      leadTimeDays: number
    }>
  }
  compliance: {
    requireApproval: boolean
    auditFrequency: 'DAILY' | 'WEEKLY' | 'MONTHLY'
    reportingRegion: 'US' | 'JP' | 'EU' | 'AU'
  }
}

// ================================
// API RESPONSE WRAPPER
// ================================

export interface InventoryApiResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: Record<string, any>
  }
  meta?: {
    timestamp: string
    requestId: string
    version: string
    warehouse?: string
    region?: string
  }
}
